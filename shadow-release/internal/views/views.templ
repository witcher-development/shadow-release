package views

import (
"errors"
"shadow_release/internal/db"
	"fmt"
)



func getVersionName(id int64, versions []db.Version) (string, error) {
	for _, item := range versions {
		if item.ID == id {
			return item.Name, nil
		}	
	}

	return "", errors.New("No Version found by id")
}
func filterByVersion(version int64, records []db.Record) []db.Record {
	var filtered []db.Record
	for _, item := range records {
		if item.Version == version {
			filtered = append(filtered, item)
		}
	}

	return filtered
}
func getMatchingRecord(currentId int64, key string, records []db.Record) (db.Record, error) {
	for _, item := range records {
		if item.Synckey == key && item.ID != currentId {
			return item, nil
		}	
	}

	return db.Record{}, errors.New("No Version found by id")
}

type VersionsUI struct {
	db.Version
	Records []RecordUI
}

type RecordUI struct {
	db.Record
	NotFound bool
	Extra bool
}

func ProcessRecords(records []db.Record, versions []db.Version) []VersionsUI {
	if len(records) == 0 || len(versions) == 0 {
		return []VersionsUI{}
	}

	result := []VersionsUI{}
	original := versions[0].ID

	// filling result with versions + empty records array
	for _, version := range versions {
		result = append(result, VersionsUI{Version: version})
	}

	// filling records for the original version
	for _, record := range records {
		if record.Version == original {
			result[0].Records = append(result[0].Records, RecordUI{Record: record})
			fmt.Println(&record.ID)
		}
	}

	// finding matching records for original records
	for _, originalRecord := range result[0].Records {
		for recordIndex, record := range records {
			fmt.Println(originalRecord.ID, record.ID)
			if originalRecord.ID != record.ID && originalRecord.Synckey == record.Synckey {
				fmt.Println("match sync key")
				for versionIndex, resultVersion := range result {
					if resultVersion.ID == record.Version {
						fmt.Println("found version to add")
						result[versionIndex].Records = append(result[versionIndex].Records, RecordUI{Record: record})	
						break
					}
				}
				break
			}
			if recordIndex == len(records) - 1 {
				for versionIndex, _ := range result {
					if result[versionIndex].ID == original {
						continue
					}
					result[versionIndex].Records = append(result[versionIndex].Records, RecordUI{NotFound: true})	
				}
			}
		}	
	}

	for _, item := range result {
		fmt.Println(item)
	}

	return result
}

templ RecordsTable(versions []VersionsUI) {
	<div>
		<div class="versions">
			if len(versions) == 0 {
				<p>no data</p>
			}
			for _, version := range versions {
				<div class="version">
					{version.Name}
				for _, record := range version.Records {
					<div class="record">
						<div class="version">
							if record.NotFound {
								<div class="empty">
									no matching record found
								</div>
							} else {
								<div>{record.Path}</div>
							}
						</div>
					</div>
				}
				</div>
			}
		</div>
	</div>
}

templ Page(records []db.Record, versions []db.Version) {
	<html>
		<head>
			<link rel="stylesheet" href="assets/styles.css"></link>
		</head>

		<body>
			@RecordsTable(ProcessRecords(records, versions))
		</body>
	</html>
}
